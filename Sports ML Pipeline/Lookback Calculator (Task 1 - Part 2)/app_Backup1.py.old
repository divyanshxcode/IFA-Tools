import streamlit as st
import pandas as pd
import numpy as np
from io import BytesIO
import time
from itertools import product

def auto_detect_encoding(df, column):
    """Auto-detect the encoding of a categorical column"""
    unique_values = df[column].dropna().unique()
    
    # Common patterns for win/loss/draw
    if set(str(v).lower() for v in unique_values) <= {'win', 'loss', 'draw', 'w', 'l', 'd'}:
        return {str(v): str(v).lower() for v in unique_values}
    
    # Common patterns for favorite/underdog
    if set(str(v).lower() for v in unique_values) <= {'true', 'false', '1', '0', 'yes', 'no', 'fav', 'underdog', 'favorite'}:
        true_values = ['true', '1', 'yes', 'fav', 'favorite']
        false_values = ['false', '0', 'no', 'underdog']
        encoding = {}
        for v in unique_values:
            if str(v).lower() in true_values:
                encoding[str(v)] = True
            elif str(v).lower() in false_values:
                encoding[str(v)] = False
        return encoding
    
    # Common patterns for home/away
    if set(str(v).lower() for v in unique_values) <= {'home', 'away', 'h', 'a'}:
        return {str(v): str(v).lower() for v in unique_values}
    
    # Default: return as-is
    return {str(v): str(v) for v in unique_values}

def compute_rolling_averages(df, selected_numeric_cols, result_config, favorite_config, home_away_config):
    """
    Compute rolling averages for each team based on previous matches only.
    Generates ALL possible combinations of filters.
    """
    # Sort by Team and Date to ensure chronological order
    df = df.sort_values(['Team', 'Date', 'MatchID']).reset_index(drop=True)
    
    # Define window sizes
    windows = {'L5': 5, 'L10': 10, 'All': None}
    
    # Define aggregation functions
    agg_functions = {
        'avg': lambda x: x.mean() if len(x) > 0 else np.nan,
        'median': lambda x: x.median() if len(x) > 0 else np.nan
    }
    
    # Build filter combinations
    filter_combinations = []
    
    # Result filters: [win, loss, draw, blank]
    result_filters = ['blank']  # blank means no filter
    if result_config and result_config['enabled']:
        result_filters.extend(result_config['values'].keys())
    
    # Favorite filters: [fav, underdog, blank]
    favorite_filters = ['blank']  # blank means no filter
    if favorite_config and favorite_config['enabled']:
        favorite_filters.extend(favorite_config['values'].keys())
    
    # Home/Away filters: [home, away, blank]
    home_away_filters = ['blank']  # blank means no filter
    if home_away_config and home_away_config['enabled']:
        home_away_filters.extend(home_away_config['values'].keys())
    
    # Generate all combinations
    for result_filter in result_filters:
        for favorite_filter in favorite_filters:
            for home_away_filter in home_away_filters:
                filter_combinations.append({
                    'result': result_filter,
                    'favorite': favorite_filter,
                    'home_away': home_away_filter
                })
    
    # Generate all column names that will be created
    new_columns = []
    for combo in filter_combinations:
        for window_key in windows.keys():
            for agg_name in agg_functions.keys():
                for col in selected_numeric_cols:
                    # Build column name based on active filters
                    name_parts = []
                    
                    if combo['result'] != 'blank':
                        name_parts.append(combo['result'])
                    
                    name_parts.append(agg_name)
                    
                    if combo['favorite'] != 'blank':
                        name_parts.append(combo['favorite'])
                    
                    if combo['home_away'] != 'blank':
                        name_parts.append(combo['home_away'])
                    
                    name_parts.append(col)
                    name_parts.append(window_key)
                    
                    col_name = '_'.join(name_parts)
                    new_columns.append(col_name)
    
    # Initialize result dataframe with all new columns
    result_df = df.copy()
    for col in new_columns:
        result_df[col] = 0  # Initialize with 0 instead of NaN
    
    # Process each team separately
    teams = df['Team'].unique()
    total_rows = len(df)
    processed_rows = 0
    
    # Create progress bars
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for team_idx, team in enumerate(teams):
        team_data = df[df['Team'] == team].copy()
        
        # For each row in the team's data
        for idx in range(len(team_data)):
            current_row_idx = team_data.index[idx]
            
            # Get all previous matches for this team (before current date/match)
            prev_matches = team_data.iloc[:idx]  # All rows before current in sorted order
            
            if len(prev_matches) > 0:
                # Process each filter combination
                for combo in filter_combinations:
                    # Start with all previous matches
                    filtered_matches = prev_matches.copy()
                    
                    # Apply result filter if not blank
                    if combo['result'] != 'blank' and result_config and result_config['enabled']:
                        result_value = result_config['values'][combo['result']]
                        filtered_matches = filtered_matches[
                            filtered_matches[result_config['column']] == result_value
                        ]
                    
                    # Apply favorite filter if not blank
                    if combo['favorite'] != 'blank' and favorite_config and favorite_config['enabled']:
                        favorite_value = favorite_config['values'][combo['favorite']]
                        filtered_matches = filtered_matches[
                            filtered_matches[favorite_config['column']] == favorite_value
                        ]
                    
                    # Apply home/away filter if not blank
                    if combo['home_away'] != 'blank' and home_away_config and home_away_config['enabled']:
                        home_away_value = home_away_config['values'][combo['home_away']]
                        filtered_matches = filtered_matches[
                            filtered_matches[home_away_config['column']] == home_away_value
                        ]
                    
                    # Apply window sizes and compute statistics
                    for window_key, window_size in windows.items():
                        # Apply window and check if we have enough data
                        if window_size is None:  # 'All' case
                            windowed_matches = filtered_matches
                            has_enough_data = len(windowed_matches) > 0  # For 'All', any data is enough
                        else:
                            # For L5 and L10, we need EXACTLY that many or more matches
                            if len(filtered_matches) >= window_size:
                                windowed_matches = filtered_matches.tail(window_size)
                                has_enough_data = True
                            else:
                                # Not enough data, set to 0
                                windowed_matches = pd.DataFrame()
                                has_enough_data = False
                        
                        # Compute statistics for each aggregation function
                        for agg_name, agg_func in agg_functions.items():
                            for col in selected_numeric_cols:
                                # Build column name
                                name_parts = []
                                
                                if combo['result'] != 'blank':
                                    name_parts.append(combo['result'])
                                
                                name_parts.append(agg_name)
                                
                                if combo['favorite'] != 'blank':
                                    name_parts.append(combo['favorite'])
                                
                                if combo['home_away'] != 'blank':
                                    name_parts.append(combo['home_away'])
                                
                                name_parts.append(col)
                                name_parts.append(window_key)
                                
                                col_name = '_'.join(name_parts)
                                
                                # Compute statistic only if we have enough data
                                if has_enough_data and col in windowed_matches.columns and len(windowed_matches) > 0:
                                    stat_value = agg_func(windowed_matches[col])
                                    # Handle NaN results (e.g., from empty series after filtering)
                                    if pd.isna(stat_value):
                                        result_df.at[current_row_idx, col_name] = 0
                                    else:
                                        result_df.at[current_row_idx, col_name] = stat_value
                                else:
                                    # Not enough data or column not found, set to 0
                                    result_df.at[current_row_idx, col_name] = 0
            
            # Update progress
            processed_rows += 1
            progress_percentage = processed_rows / total_rows
            progress_bar.progress(progress_percentage)
            status_text.text(f"Processing: {processed_rows}/{total_rows} rows ({progress_percentage:.1%}) | Current team: {team}")
    
    # Clear status text
    status_text.text("‚úÖ Processing completed!")
    
    return result_df

def main():
    st.title("üìä Rolling Averages Calculator")
    st.markdown("Upload your CSV file to compute rolling averages based on team performance, conditions, and match results.")
    
    # File uploader
    uploaded_file = st.file_uploader(
        "Choose a CSV file", 
        type="csv",
        help="Upload a CSV file with data containing columns like Team, Date, MatchID, etc."
    )
    
    if uploaded_file is not None:
        try:
            # Read the CSV file
            df = pd.read_csv(uploaded_file)
            
            st.success(f"‚úÖ File uploaded successfully! Shape: {df.shape}")
            
            # Show preview of uploaded data
            st.subheader("üìä Data Preview")
            st.dataframe(df.head(10))
            
            # Validate required columns
            required_cols = ['Team', 'Date', 'MatchID']
            missing_cols = [col for col in required_cols if col not in df.columns]
            
            if missing_cols:
                st.error(f"‚ùå Missing required columns: {missing_cols}")
                st.info("Required columns: Team, Date, MatchID")
                return
            
            # Convert Date to datetime if it's not already
            if df['Date'].dtype == 'object':
                df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
            
            # Show data info
            st.subheader("üìà Dataset Information")
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Records", len(df))
            with col2:
                st.metric("Unique Teams", df['Team'].nunique())
            with col3:
                st.metric("Date Range", f"{df['Date'].min().strftime('%Y-%m-%d')} to {df['Date'].max().strftime('%Y-%m-%d')}")
            
            # Configuration Section
            st.subheader("‚öôÔ∏è Configuration Options")
            
            # 1. Numeric Columns Selection
            numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
            exclude_cols = ['MatchID', 'Date']
            available_numeric_cols = [col for col in numeric_cols if col not in exclude_cols]
            
            st.write("**1. Select Numeric Columns for Rolling Statistics:**")
            selected_numeric_cols = st.multiselect(
                "Choose columns to calculate rolling statistics for:",
                options=available_numeric_cols,
                default=available_numeric_cols,  # Select all by default
                help="Select the numeric columns you want to calculate rolling averages and medians for"
            )
            
            # 2. Win/Loss/Draw Configuration
            st.write("**2. Win/Loss/Draw Filter (optional):**")
            result_config = {'enabled': False}
            
            has_result_filter = st.checkbox("Include Win/Loss/Draw combinations", help="Filter by match results")
            
            if has_result_filter:
                # Find potential result columns
                potential_result_cols = [col for col in df.columns if 'result' in col.lower() or 'outcome' in col.lower()]
                
                if potential_result_cols:
                    result_column = st.selectbox(
                        "Select the result column:",
                        options=potential_result_cols,
                        help="Choose the column that contains match results"
                    )
                else:
                    result_column = st.selectbox(
                        "Select the result column:",
                        options=df.columns.tolist(),
                        help="Choose the column that contains match results"
                    )
                
                # Auto-detect encoding
                auto_encoding = auto_detect_encoding(df, result_column)
                unique_values = df[result_column].dropna().unique()
                
                st.write(f"Unique values in {result_column}: {list(unique_values)}")
                st.write("**Configure result encoding:**")
                
                result_encoding = {}
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    win_value = st.selectbox(
                        "Value for 'Win':",
                        options=['None'] + list(unique_values),
                        index=0 if 'win' not in str(unique_values).lower() else 
                              [str(v).lower() for v in unique_values].index('win') + 1 if 'win' in [str(v).lower() for v in unique_values] else 0
                    )
                    if win_value != 'None':
                        result_encoding['win'] = win_value
                
                with col2:
                    loss_value = st.selectbox(
                        "Value for 'Loss':",
                        options=['None'] + list(unique_values),
                        index=0 if 'loss' not in str(unique_values).lower() else 
                              [str(v).lower() for v in unique_values].index('loss') + 1 if 'loss' in [str(v).lower() for v in unique_values] else 0
                    )
                    if loss_value != 'None':
                        result_encoding['loss'] = loss_value
                
                with col3:
                    draw_value = st.selectbox(
                        "Value for 'Draw':",
                        options=['None'] + list(unique_values),
                        index=0 if 'draw' not in str(unique_values).lower() else 
                              [str(v).lower() for v in unique_values].index('draw') + 1 if 'draw' in [str(v).lower() for v in unique_values] else 0
                    )
                    if draw_value != 'None':
                        result_encoding['draw'] = draw_value
                
                if result_encoding:
                    result_config = {
                        'enabled': True,
                        'column': result_column,
                        'values': result_encoding
                    }
                    st.success(f"‚úÖ Result filter configured: {list(result_encoding.keys())}")
            
            # 3. Favorite/Underdog Configuration
            st.write("**3. Favorite/Underdog Filter (optional):**")
            favorite_config = {'enabled': False}
            
            has_favorite_filter = st.checkbox("Include Favorite/Underdog combinations", help="Filter by favorite status")
            
            if has_favorite_filter:
                # Find potential favorite columns
                potential_fav_cols = [col for col in df.columns if 'fav' in col.lower() or 'underdog' in col.lower()]
                
                if potential_fav_cols:
                    favorite_column = st.selectbox(
                        "Select the favorite column:",
                        options=potential_fav_cols,
                        help="Choose the column that indicates favorite/underdog status"
                    )
                else:
                    favorite_column = st.selectbox(
                        "Select the favorite column:",
                        options=df.columns.tolist(),
                        help="Choose the column that indicates favorite/underdog status"
                    )
                
                # Auto-detect encoding
                unique_values = df[favorite_column].dropna().unique()
                st.write(f"Unique values in {favorite_column}: {list(unique_values)}")
                
                # Try to auto-detect True/False pattern
                auto_detected = False
                if len(unique_values) == 2:
                    val1, val2 = unique_values
                    if str(val1).lower() in ['true', '1', 'yes', 'fav', 'favorite'] and str(val2).lower() in ['false', '0', 'no', 'underdog']:
                        favorite_encoding = {'fav': val1, 'underdog': val2}
                        auto_detected = True
                        st.success(f"‚úÖ Auto-detected encoding: Favorite={val1}, Underdog={val2}")
                    elif str(val2).lower() in ['true', '1', 'yes', 'fav', 'favorite'] and str(val1).lower() in ['false', '0', 'no', 'underdog']:
                        favorite_encoding = {'fav': val2, 'underdog': val1}
                        auto_detected = True
                        st.success(f"‚úÖ Auto-detected encoding: Favorite={val2}, Underdog={val1}")
                
                if not auto_detected:
                    st.write("**Configure favorite encoding:**")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        fav_value = st.selectbox(
                            "Value for 'Favorite':",
                            options=['None'] + list(unique_values)
                        )
                    
                    with col2:
                        underdog_value = st.selectbox(
                            "Value for 'Underdog':",
                            options=['None'] + list(unique_values)
                        )
                    
                    favorite_encoding = {}
                    if fav_value != 'None':
                        favorite_encoding['fav'] = fav_value
                    if underdog_value != 'None':
                        favorite_encoding['underdog'] = underdog_value
                
                if favorite_encoding:
                    favorite_config = {
                        'enabled': True,
                        'column': favorite_column,
                        'values': favorite_encoding
                    }
                    st.success(f"‚úÖ Favorite filter configured: {list(favorite_encoding.keys())}")
            
            # 4. Home/Away Configuration
            st.write("**4. Home/Away Filter (optional):**")
            home_away_config = {'enabled': False}
            
            has_home_away_filter = st.checkbox("Include Home/Away combinations", help="Filter by home/away status")
            
            if has_home_away_filter:
                # Find potential home/away columns
                potential_home_cols = [col for col in df.columns if 'home' in col.lower() or 'away' in col.lower() or 'venue' in col.lower()]
                
                if potential_home_cols:
                    home_away_column = st.selectbox(
                        "Select the home/away column:",
                        options=potential_home_cols,
                        help="Choose the column that indicates home/away status"
                    )
                else:
                    home_away_column = st.selectbox(
                        "Select the home/away column:",
                        options=df.columns.tolist(),
                        help="Choose the column that indicates home/away status"
                    )
                
                # Auto-detect encoding
                unique_values = df[home_away_column].dropna().unique()
                st.write(f"Unique values in {home_away_column}: {list(unique_values)}")
                
                # Try to auto-detect Home/Away pattern
                auto_detected = False
                if len(unique_values) == 2:
                    val1, val2 = unique_values
                    if str(val1).lower() in ['home', 'h', '1', 'true'] and str(val2).lower() in ['away', 'a', '0', 'false']:
                        home_away_encoding = {'home': val1, 'away': val2}
                        auto_detected = True
                        st.success(f"‚úÖ Auto-detected encoding: Home={val1}, Away={val2}")
                    elif str(val2).lower() in ['home', 'h', '1', 'true'] and str(val1).lower() in ['away', 'a', '0', 'false']:
                        home_away_encoding = {'home': val2, 'away': val1}
                        auto_detected = True
                        st.success(f"‚úÖ Auto-detected encoding: Home={val2}, Away={val1}")
                
                if not auto_detected:
                    st.write("**Configure home/away encoding:**")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        home_value = st.selectbox(
                            "Value for 'Home':",
                            options=['None'] + list(unique_values)
                        )
                    
                    with col2:
                        away_value = st.selectbox(
                            "Value for 'Away':",
                            options=['None'] + list(unique_values)
                        )
                    
                    home_away_encoding = {}
                    if home_value != 'None':
                        home_away_encoding['home'] = home_value
                    if away_value != 'None':
                        home_away_encoding['away'] = away_value
                
                if home_away_encoding:
                    home_away_config = {
                        'enabled': True,
                        'column': home_away_column,
                        'values': home_away_encoding
                    }
                    st.success(f"‚úÖ Home/Away filter configured: {list(home_away_encoding.keys())}")
            
            # Show configuration summary
            with st.expander("üìã Configuration Summary"):
                st.write(f"**Selected Numeric Columns:** {len(selected_numeric_cols)}")
                if selected_numeric_cols:
                    st.write(", ".join(selected_numeric_cols[:5]) + ("..." if len(selected_numeric_cols) > 5 else ""))
                
                if result_config['enabled']:
                    st.write(f"**Result Filters:** {list(result_config['values'].keys())} + blank")
                else:
                    st.write("**Result Filters:** None")
                
                if favorite_config['enabled']:
                    st.write(f"**Favorite Filters:** {list(favorite_config['values'].keys())} + blank")
                else:
                    st.write("**Favorite Filters:** None")
                
                if home_away_config['enabled']:
                    st.write(f"**Home/Away Filters:** {list(home_away_config['values'].keys())} + blank")
                else:
                    st.write("**Home/Away Filters:** None")
                
                # Calculate total combinations
                result_count = len(result_config['values']) + 1 if result_config['enabled'] else 1
                favorite_count = len(favorite_config['values']) + 1 if favorite_config['enabled'] else 1
                home_away_count = len(home_away_config['values']) + 1 if home_away_config['enabled'] else 1
                
                total_combinations = result_count * favorite_count * home_away_count
                total_new_cols = total_combinations * len(selected_numeric_cols) * 3 * 2  # 3 windows * 2 agg functions
                
                st.write(f"**Total Filter Combinations:** {total_combinations}")
                st.write(f"**Estimated New Columns:** ~{total_new_cols}")
                st.write("**Statistics:** Average + Median for each combination")
                st.write("**Windows:** L5, L10, All")
            
            # Show example column names
            if selected_numeric_cols:
                with st.expander("üìù Example Column Names"):
                    example_col = selected_numeric_cols[0]
                    st.write("Sample column names that will be generated:")
                    
                    # Show a few examples
                    examples = []
                    if result_config['enabled'] and favorite_config['enabled'] and home_away_config['enabled']:
                        first_result = list(result_config['values'].keys())[0]
                        first_fav = list(favorite_config['values'].keys())[0]
                        first_home = list(home_away_config['values'].keys())[0]
                        examples.append(f"‚Ä¢ {first_result}_avg_{first_fav}_{first_home}_{example_col}_L5")
                        examples.append(f"‚Ä¢ {first_result}_median_{first_fav}_{first_home}_{example_col}_L10")
                    
                    if favorite_config['enabled']:
                        first_fav = list(favorite_config['values'].keys())[0]
                        examples.append(f"‚Ä¢ avg_{first_fav}_{example_col}_L5")
                        examples.append(f"‚Ä¢ median_{first_fav}_{example_col}_All")
                    
                    examples.append(f"‚Ä¢ avg_{example_col}_L5")
                    examples.append(f"‚Ä¢ median_{example_col}_L10")
                    
                    for example in examples:
                        st.write(example)
            
            # Process button
            if selected_numeric_cols:  # Only show button if at least one numeric column is selected
                if st.button("üöÄ Process Data & Compute Rolling Statistics", type="primary"):
                    with st.spinner("Computing all rolling statistics combinations... This may take a few minutes for large datasets."):
                        start_time = time.time()
                        
                        # Compute rolling averages
                        processed_df = compute_rolling_averages(
                            df, 
                            selected_numeric_cols, 
                            result_config, 
                            favorite_config, 
                            home_away_config
                        )
                        
                        end_time = time.time()
                        processing_time = end_time - start_time
                    
                    st.success(f"‚úÖ Processing completed in {processing_time:.2f} seconds!")
                    
                    # Show results
                    st.subheader("üìã Processed Data Preview")
                    st.dataframe(processed_df.head(10))
                    
                    st.subheader("üìä New Columns Added")
                    new_cols = [col for col in processed_df.columns if col not in df.columns]
                    st.info(f"Added {len(new_cols)} new rolling statistics columns")
                    
                    # Show some example new columns
                    if new_cols:
                        st.write("Sample new columns:")
                        for i, col in enumerate(new_cols[:15]):  # Show first 15
                            st.write(f"‚Ä¢ {col}")
                        if len(new_cols) > 15:
                            st.write(f"... and {len(new_cols) - 15} more columns")
                    
                    # Download button
                    st.subheader("üíæ Download Processed Data")
                    
                    # Convert to CSV for download
                    csv_buffer = BytesIO()
                    processed_df.to_csv(csv_buffer, index=False)
                    csv_data = csv_buffer.getvalue()
                    
                    st.download_button(
                        label="üì• Download Processed CSV",
                        data=csv_data,
                        file_name=f"processed_data_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv",
                        help="Download the dataset with all computed rolling statistics"
                    )
                    
                    # Show summary statistics
                    st.subheader("üìà Summary Statistics")
                    st.write("Sample rolling statistics for first team:")
                    first_team = processed_df['Team'].iloc[0]
                    team_sample = processed_df[processed_df['Team'] == first_team].head(5)
                    
                    # Show only the new columns for the sample
                    sample_new_cols = [col for col in team_sample.columns if col in new_cols]
                    if sample_new_cols:
                        basic_cols = ['Team', 'Date']
                        if result_config['enabled']:
                            basic_cols.append(result_config['column'])
                        if favorite_config['enabled']:
                            basic_cols.append(favorite_config['column'])
                        if home_away_config['enabled']:
                            basic_cols.append(home_away_config['column'])
                        
                        st.dataframe(team_sample[basic_cols + sample_new_cols[:10]])
            else:
                st.warning("‚ö†Ô∏è Please select at least one numeric column to calculate rolling statistics.")
        
        except Exception as e:
            st.error(f"‚ùå Error processing file: {str(e)}")
            st.info("Please ensure your CSV file has the correct format and required columns.")
    
    else:
        st.info("üëÜ Please upload a CSV file to get started.")
        
        # Show example format
        st.subheader("üìã Expected CSV Format")
        st.markdown("""
        Your CSV should contain these columns:
        - **Team**: Team/Entity identifier
        - **Date**: Date of the record (YYYY-MM-DD format preferred)
        - **MatchID**: Unique identifier for each record
        - **Optional columns for filtering:**
          - Result column (e.g., Win/Loss/Draw)
          - Favorite column (e.g., True/False or Favorite/Underdog)
          - Home/Away column (e.g., Home/Away or H/A)
        - **Numeric columns**: Any numeric data you want rolling statistics for
        
        The tool will calculate rolling averages AND medians (Last 5, Last 10, All-time) for ALL possible combinations of your selected filters.
        """)

if __name__ == "__main__":
    main()
